(function(o,b){typeof exports=="object"&&typeof module<"u"?b(exports):typeof define=="function"&&define.amd?define(["exports"],b):(o=typeof globalThis<"u"?globalThis:o||self,b(o["run-types"]={}))})(this,function(o){"use strict";const b="empty",$="any",c="native",a=Object.freeze({valid:!0}),T=(r,n)=>`Expected ${r} but got ${n}`,g=r=>`type: ${r}`,N=r=>r.__type===c?a:{valid:!1,errors:{type:T(g(c),g(r.__type))}},U=r=>n=>n.__type===c&&n.native===r?a:{valid:!1,errors:{type:T(`native ${r}`,g(n.__type))}},O={string:{__type:c,native:"string"},number:{__type:c,native:"number"},boolean:{__type:c,native:"boolean"}},v="map",A="list",h="tuple",E="function";function u(r,n,e){return`${f(n)} not assignable to ${f(r)}; ${e}`}function I(r){return r.reduce((n,e)=>e.valid?n:{valid:!1,errors:{...n.valid?{}:n.errors,...e.errors}},a)}function d(r,n,e){if(r){const s=Object.entries(r).map(([t,i])=>{var m;if(n[t]){const p=n[t](i)((m=e.constraints)==null?void 0:m[t]);if(!p.valid)return{valid:!1,errors:{[t]:p.errors[t]}}}return a});return I(s)}return a}const j=(r,n)=>e=>{const s=d(r.constraints,n,e);return s.valid?e.__type===c&&e.native===r.native?a:{valid:!1,errors:{type:u(e,r,"native types do not match")}}:s},M=(r,n)=>e=>{const s=d(r.constraints,n,e);if(!s.valid)return s;if(e.__type==="map"){const t=Object.keys(r.members);for(let i=0;i<t.length;i++){const m=t[i];if(!(m in e.members))return{valid:!1,errors:{type:u(e,r,`missing key: "${m}"`)}};const y=e.members[m],p=r.members[m];if(!l(p,n)(y).valid)return{valid:!1,errors:{type:u(e,r,`key "${m}" not assignable to ${f(y)}`)}}}return a}return{valid:!1,errors:{type:u(e,r,"type is not a map")}}};function S(r,n){return e=>{if(e.__type==="list"){const s=d(r.constraints,n,e);if(!s.valid)return s;const t=l(r.members,n)(e.members);return t.valid?a:{valid:!1,errors:{type:u(e,r,`list members do not match: ${t.errors.type}`)}}}return{valid:!1,errors:{type:u(e,r,"type is not a list")}}}}function k(r,n){return e=>{if(e.__type==="tuple"){const s=d(r.constraints,n,e);if(!s.valid)return s;if(e.members.length!==r.members.length)return{valid:!1,errors:{type:u(e,r,"tuple length does not match")}};for(let t=0;t<r.members.length;t++)if(!l(r.members[t],n)(e.members[t]).valid)return{valid:!1,errors:{type:u(e,r,`tuple member ${t} not assignable to ${f(e.members[t])}`)}};return a}return{valid:!1,errors:{type:u(e,r,"type is not a tuple")}}}}function F(r,n){return e=>{if(e.__type==="function"){const s=d(r.constraints,n,e);if(!s.valid)return s;const t=l(r.returns,n)(e.returns);if(!t.valid)return t;if(r.args.length!==e.args.length)return{valid:!1,errors:{type:u(e,r,"function argument length does not match")}};for(let i=0;i<r.args.length;i++)if(!l(r.args[i],n)(e.args[i]).valid)return{valid:!1,errors:{type:u(e,r,`function argument ${i} not assignable to ${f(e.args[i])}`)}};return a}return{valid:!1,errors:{type:u(e,r,"type is not a function")}}}}function P(r,n){return e=>{const s=d(r.constraints,n,e);if(!s.valid)return s;for(let t=0;t<r.members.length;t++)if(l(r.members[t],n)(e).valid)return a;return{valid:!1,errors:{type:u(e,r,"type assignable to any member of union")}}}}function C(r,n){return e=>{const s=d(r.constraints,n,e);if(!s.valid)return s;for(let t=0;t<r.members.length;t++){const i=l(r.members[t],n)(e);if(!i.valid)return{valid:!1,errors:{type:u(e,r,i.errors.type)}}}return a}}const l=(r,n)=>{switch(r.__type){case c:return j(r,n);case v:return M(r,n);case A:return S(r,n);case h:return k(r,n);case E:return F(r,n);case L:return P(r,n);case V:return C(r,n);case b:case $:return()=>a}};function _(r){return r.map(f).join(", ")}function f(r){switch(r.__type){case c:return`native ${r.native}`;case v:return`map {${Object.entries(r.members).map(([n,e])=>`${n}: ${f(e)}`).join(", ")}}`;case A:return`list [${_([r.members])}]`;case h:return`tuple [${_(r.members)}]`;case E:return`function (${_(r.args)}) => ${f(r.returns)}`;case L:return`union [${_(r.members)}]`;case V:return`intersection [${_(r.members)}]`;case b:return"[empty]";case $:return"[any]"}}function w(r,n){return{__type:"function",args:r,returns:n}}function D(r){return{__type:"union",members:[r,{__type:"empty"}]}}const L="union",V="intersection";o.NativeTypes=O,o.VALID=a,o.createFunctionType=w,o.createOptionalType=D,o.expectedErrorMessage=T,o.isAssignableTo=l,o.isNativeType=N,o.nativeTypeValidator=U,o.typeLabel=g,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
